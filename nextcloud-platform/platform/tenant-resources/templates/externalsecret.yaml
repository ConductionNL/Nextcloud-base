---
# Secret management for tenant
#
# CURRENT MODE: Direct Kubernetes Secrets
# Secrets are created manually using scripts/create-tenant-secret.sh
#
# FUTURE: Uncomment ExternalSecret when migrating to ESO

# For now, we just verify the secret exists and create placeholder if missing
apiVersion: batch/v1
kind: Job
metadata:
  name: nextcloud-secret-check
  namespace: {{ .Values.tenant.namespace | default (printf "nc-%s" .Values.tenant.name) }}
  labels:
    {{- include "tenant-resources.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 600
  backoffLimit: 1
  template:
    metadata:
      labels:
        {{- include "tenant-resources.labels" . | nindent 8 }}
        app.kubernetes.io/component: secret-check
    spec:
      restartPolicy: Never
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      serviceAccountName: secret-generator
      containers:
        - name: check
          image: bitnami/kubectl:1.28
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          command:
            - /bin/bash
            - -c
            - |
              set -e
              
              SECRET_NAME="nextcloud-secrets"
              NAMESPACE="{{ .Values.tenant.namespace | default (printf "nc-%s" .Values.tenant.name) }}"
              TENANT="{{ .Values.tenant.name }}"
              
              echo "Checking secret $SECRET_NAME in namespace $NAMESPACE..."
              
              if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" &>/dev/null; then
                echo "✓ Secret exists"
                
                # Verify required keys
                required_keys="nextcloud-username nextcloud-password s3-access-key s3-secret-key db-password"
                missing=""
                
                for key in $required_keys; do
                  if ! kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath="{.data.$key}" &>/dev/null; then
                    missing="$missing $key"
                  fi
                done
                
                if [ -n "$missing" ]; then
                  echo "⚠ Warning: Missing keys in secret:$missing"
                  echo "Update the secret with these keys before Nextcloud can start."
                  exit 1
                fi
                
                echo "✓ All required keys present"
                exit 0
              else
                echo ""
                echo "=========================================="
                echo "ERROR: Secret not found!"
                echo "=========================================="
                echo ""
                echo "Create the secret by running:"
                echo ""
                echo "  export S3_ACCESS_KEY='your-fuga-cloud-access-key'"
                echo "  export S3_SECRET_KEY='your-fuga-cloud-secret-key'"
                echo "  export DB_PASSWORD='your-postgresql-password'"
                echo "  ./scripts/create-tenant-secret.sh $TENANT --generate-admin-password"
                echo ""
                echo "Or create manually:"
                echo ""
                echo "  kubectl create secret generic nextcloud-secrets \\"
                echo "    --namespace=$NAMESPACE \\"
                echo "    --from-literal=nextcloud-username=admin \\"
                echo "    --from-literal=nextcloud-password='your-password' \\"
                echo "    --from-literal=s3-access-key='ACCESS_KEY' \\"
                echo "    --from-literal=s3-secret-key='SECRET_KEY' \\"
                echo "    --from-literal=db-username='nextcloud_$TENANT' \\"
                echo "    --from-literal=db-password='DB_PASSWORD' \\"
                echo "    --from-literal=redis-password='' \\"
                echo "    --from-literal=nextcloud-secret='\$(openssl rand -base64 48)'"
                echo ""
                exit 1
              fi

# ---
# FUTURE: ExternalSecret for Vault/Cloud backends
# Uncomment when migrating from manual secrets
#
# apiVersion: external-secrets.io/v1beta1
# kind: ExternalSecret
# metadata:
#   name: nextcloud-secrets
#   namespace: {{ .Values.tenant.namespace | default (printf "nc-%s" .Values.tenant.name) }}
#   labels:
#     {{- include "tenant-resources.labels" . | nindent 4 }}
# spec:
#   refreshInterval: {{ .Values.refreshInterval }}
#   secretStoreRef:
#     name: {{ .Values.secretStore.name }}
#     kind: {{ .Values.secretStore.kind }}
#   target:
#     name: nextcloud-secrets
#     creationPolicy: Owner
#   data:
#     - secretKey: nextcloud-password
#       remoteRef:
#         key: {{ include "tenant-resources.vaultPath" . }}
#         property: admin-password
#     - secretKey: s3-access-key
#       remoteRef:
#         key: {{ include "tenant-resources.vaultPath" . }}
#         property: s3-access-key
#     # ... etc
